//
//  AdminViewController.swift
//  SoSound
//
//  Created by Dave Brown on 8/13/18.
//

import QuartzCore
import UIKit
import MediaPlayer

struct AuthResult: Decodable {
    let status: Int
    let data: Int
    let status_message: String

//    enum CodingKeys : String, CodingKey {
//        case status
//        case data
//        case statusMessage = "status_message"
//    }

}


class AdminViewController: UIViewController, MusicDownloadDelegate, MPMediaPickerControllerDelegate {

    @IBOutlet weak var _username: UITextField!
    @IBOutlet weak var _password: UITextField!
    @IBOutlet weak var _musicStatusLabel: UILabel!
    @IBOutlet weak var _downloadBackView: UIView!
    @IBOutlet weak var _musicDownloadStatusLabel: UILabel!

    var downloadTask: URLSessionDownloadTask!
    var backgroundSession: URLSession!
    var downloadView: MusicDownloadView!
    var downloadStep: Int = 0


    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        self.downloadView = MusicDownloadView(frame: CGRect.zero)

        // do we have the files?
        if (MusicManager().verifyDownloadFiles()) {
            _musicDownloadStatusLabel.text = "Your music looks good!";
        } else {
            _musicDownloadStatusLabel.text = "No music has been downloaded.\n\nPress the Download Music button to download your So Sound music.";
        }

        let fm = FileManager.default
        let documentsDirectoryURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!

        do {
            let items = try fm.contentsOfDirectory(atPath: documentsDirectoryURL.path)

            for item in items {
                log("Found \(item)")
            }
        } catch {
            // failed to read directory â€“ bad permissions, perhaps?
        }
    }

    @IBAction func downloadMusicTapped(_ sender: Any) {

        // Create the action buttons for the alert.
        let defaultAction = UIAlertAction(title: "Download", style: .default) { (action) in

            self.view.addSubview(self.downloadView)
            self.downloadView.frame = CGRect(x: self.view.frame.width / 4, y: self.view.frame.height / 4, width: self.view.frame.width / 2, height: self.view.frame.height / 2)
            DispatchQueue.main.async {
                // execute async on main thread
                log("Starting music download process")
                MusicManager().downloadMusic(downloadDelegate: self)
            }
        }
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel) { (action) in
            // Respond to user selection of the action.
        }
        // Create and configure the alert controller.
        let alert = UIAlertController(title: "Music Download", message: "You are about to start the music download process. This will take an extended amount of time.\n\nAre you sure?", preferredStyle: UIAlertControllerStyle.alert)
        alert.addAction(defaultAction)
        alert.addAction(cancelAction)
        self.present(alert, animated: true, completion: nil)
    }

    @IBAction func pickMusicTapped(_ sender: Any) {

//        let myMediaPlayer = MPMusicPlayerApplicationController.applicationQueuePlayer()
//        // Add a playback queue containing all songs on the device
//        myMediaPlayer.setQueue(with: MPMediaQuery.songs())
//        // Start playing from the beginning of the queue
//        myMediaPlayer.play()
        let myMediaPickerVC = MPMediaPickerController(mediaTypes: MPMediaType.music)
        myMediaPickerVC.allowsPickingMultipleItems = true
//        myMediaPickerVC.popoverPresentationController?.sourceView = self.view
        myMediaPickerVC.delegate = self
        self.present(myMediaPickerVC, animated: true, completion: nil)
    }

    func mediaPicker(_ mediaPicker: MPMediaPickerController, didPickMediaItems mediaItemCollection: MPMediaItemCollection) {

        if #available(iOS 10.3, *) {
            let myMediaPlayer = MPMusicPlayerApplicationController.applicationQueuePlayer()
//            let pickedSongData: Data = UserDefaults.standard.object(forKey: "picked_song") as! Data

//            if let pickedSong = NSKeyedUnarchiver.unarchiveObject(with: pickedSongData) as? MPMediaItemCollection {
//                myMediaPlayer.setQueue(with: pickedSong)
////            mediaPicker.dismiss(animated: true, completion: nil)
//                myMediaPlayer.play()
//
////            // Add a playback queue containing all songs on the device
////            myMediaPlayer.setQueue(with: MPMediaQuery.songs())
////            // Start playing from the beginning of the queue
////            myMediaPlayer.play()
                let data: Data = NSKeyedArchiver.archivedData(withRootObject: mediaItemCollection)
                UserDefaults.standard.set(data, forKey: "picked_song")
                mediaPicker.dismiss(animated: true, completion: nil)

//            }

        } else {
            // Fallback on earlier versions
        }
    }

    func mediaPickerDidCancel(_ mediaPicker: MPMediaPickerController) {
        mediaPicker.dismiss(animated: true, completion: nil)
    }

    func downloadComplete(error: Bool) {

        if (!error) {
            _musicDownloadStatusLabel.text = "Music download complete.";
        } else {
            _musicDownloadStatusLabel.text = "There was a problem with your music download.";
        }
        self.downloadView.removeFromSuperview()
    }

    func downloadProgress(progressText: String) {

        DispatchQueue.main.async {
            //Update your UI here
            self.downloadView.downloadLabel.text = progressText
        }
    }

    @IBAction func authenticateTouched(_ sender: Any) {

        let url: String = "http://staging.sosoundsolutions.com/wp-content/plugins/so-sound/restapi/api.php?username=davebrown&password=d0g50f3@R"
        let request: NSMutableURLRequest = NSMutableURLRequest(url: NSURL(string: url)! as URL)
        request.httpMethod = "GET"
        let session = URLSession.shared
        let task = session.dataTask(with: request as URLRequest, completionHandler: { data, response, error -> Void in
            if (error != nil) {
                let l = 9;
//                onFailure(error!)
            } else {
                guard let dataResponse = data, error == nil else {
                    print(error?.localizedDescription ?? "Response Error")
                    return
                }
                do {

//                    let json = try JSONSerialization.jsonObject(with: dataResponse, options: [])

                    do {
                        let authResponse = try JSONDecoder().decode(AuthResult.self, from: dataResponse);
                    } catch let error {
                        print(error)
                    }
                    //here dataResponse received from a network request
                    let p = 9;
                } catch let parsingError {
                    print("Error", parsingError)
                }
//                if let unwrappedData = data {
//
//                    do {
//                        let json = try JSONSerialization.jsonObject(with: unwrappedData, options: [])
//                        let l = 9;
//                    } catch {
//                        let l = 9;
//                    }
//                }
//                onSuccess(result)
            }
        })
        task.resume()
    }

}
